# 述职

## Android业务支撑与技术积累

​	Android业务支撑我主要负责过东家小院的研发和领现金项目框架的搭建以及关注组件的封装和维护工作。在这些Android原生项目的不断迭代过程中，我总结出主要面临的三个问题：

>- 代码结构混乱
>
>  东家小院是我从0到1搭建起来的第一个项目，由于早期对项目的架构知识掌握不足，导致代码结构混乱，层次不清，Activity和Fragment越来越多的同时承担了Presenter和View的职责，导致他们变得极其臃肿且难以维护，MVP项目架构最终也是面目全非。
>
>- 技术方案不统一
>
>  由于在项目工时紧张时有其他团队成员的研发支持，大家为了项目的快速上线，各自引入了自己熟悉的技术方案，导致项目慢慢变得臃肿，复杂的业务代码逻辑不清晰难以理解；
>
>- 冗余代码
>
>  同一套代码中同时封装了很多功能类似的组件，这些高度定制的组件复用性不强，不仅增加了包大小，而且增加了项目后期的维护成本；

​	为了解决这些问题，我在需求的迭代过程中不断的进行小范围的改进，然后通过研究了Google推出的基于MVP架构的demo后并结合自己之前的一些经验，针对性的做了部分调整，最后形成了一套自己的项目搭建方案并且在领现金项目的搭建过程中得到了应用：上图就是领现金的项目架构。

- View Layer: 只负责UI的绘制呈现，包含Activity、Fragment和一些自定义的UI组件，View层需要实现ViewInterface接口。Activity在项目中不再负责View的职责，仅仅是一个全局的控制者，负责创建View和Presenter的实例；
- Model Layer: 负责检索、存储、操作数据，包括来自网络和SharedPreferences的数据；
- Presenter Layer: 作为View Layer和Module Layer的之间的纽带，它从model层中获取数据，然后调用View的接口去控制View；
- Contract: 参照Google的demo加入契约类Contract来统一管理View和Presenter的接口，使得某一功能模块的接口能更加直观的呈现出来，这样做有利于项目的后期维护。

除了业务上的拆分，通过分包、类描述和方法注释使得代码有了足够明确的开发规范和标准。细致到了每一个类应该放到哪个包下，哪个类具体应该负责什么职责等。这对于我们的Code Review、接手他人的功能模块等都提供了极大的便利。

​	但是MVP架构也会带来以下新的问题：由于大量的业务逻辑处理转移到了Presenter层，在一些复杂的业务场景中Presenter同样会变得臃肿难懂。架构图中有个Data Repository模块，Data Repository在这里的作用是可以将原本由Presenter处理的部分逻辑转移到这里来处理，包括数据的校验、部分单纯只与数据相关的逻辑等，向Presenter屏蔽数据处理细节，作为Presenter就不必关心Model层传递过来的数据到底是来至网络还是来自本地文件。

​    通过上述的架构基本上可以解决第一个问题，第二个问题技术方案不统一的问题，通过在项目中引入常用的library并在基类中进行封装对外提供统一的调用接口并做好注释与方法调用示例说明，如有必要还可以通过对外提供抽象方法或者接口供调用方自己去实现相关方法。第三个问题通过封装通用化的组件解决。组件的封装要保持开闭原则，既要保证公有逻辑的不变性还要保持私有逻辑的可扩展性。避免重复造轮子，降低项目的复杂度。合理控制各组件拆分粒度，太小的公有模块不足以构成单独组件，我们先放到Common Layer层中，在后期不断的重构迭代中视情况进行进一步的拆分。

## RN业务支撑与技术积累

1、风控校验功能组件封装、Feeds流列表组件封装、进度条组件、滑动列表指示器组件、RN弹窗组件、翻转数字动画组件、静态容器组件、按钮呼吸动效组件、沉浸式导航栏组件、状态栏颜色主题切换组件、轻量级父子组件事件传递框架

​	我主要负责的是领京豆模块以及领京豆大促活动页的研发工作，自我接手领京豆模块后，总共进行了两次大改版，四个大促活动页的研发工作。我面临的主要挑战分别是：

> - 维护成本高
>
>   由于之前领京豆模块的维护团队众多，代码风格不一致，魔法值众多，使得项目维护困难；
>
> - 体验问题
>
>   因为RN是通过jsbridge桥接原生的能力，体验上本就有一些性能瓶颈，但是人为的代码堆砌，导致代码运行性能低下，用户体验不佳；
>
> - 工时压力
>
>   领京豆大促活动页往往是倒排工时，如何能够从0到1快速搭建工程，辅助业务快速上线，缓解研发的工时压力，这也是RN业务开发需要面对的一个主要挑战。

那么如何解决这些问题呢？我主要从三个方面入手：

> - 降低代码的维护成本
>
>   在业务粒度上，将代码按照业务逻辑进行分拆解耦。RN部分进行了弹窗治理，H5进行了发布平台的迁移。
>
> - 组件封装
>
>   在组件粒度上，为了避免重复开发和降低项目的复杂度，领京豆封装了大量的可复用组件，按照其用途分为UI组件和功能性组件。那些粒度过小的公有逻辑不足以进行组件的封装则抽取出来作为工具类中的方法进行维护，后续如果该公有逻辑涉及到多个方法的调用或者逻辑复杂时，则将其进一步封装为组件进行复用。经过这一步之后，组件间有了清晰的代码边界，达到了组件间的0耦合，组件内部逻辑内聚，符合单一职责，对外提供统一的属性供引用方进行配置化调用。经过上述的两步之后，代码的可维护性和可复用性得到了保证。
>
> - 性能优化
>
>   在代码粒度上，总结起来就是尽可能减少组件的渲染次数。其中首开优化，最重要的优化就是优先渲染首屏的楼层，在列表的滑动过程中首屏的楼层也不参与楼层的回收和复用的过程，让用户可以在任何位置回到顶部时都可以第一时间看到首屏的楼层。然后是列表滑动的优化，在列表迅速滑动的过程中，为了节省cpu和内存的开销，通过对列表在滑动的过程中状态发生的变化图片进行色块替换，避免了图片的无效加载。让列表滑动更加的流畅。其次就是包大小的优化，领京豆的bundle中存在大量的本地图片，通过对这些图片进行分类，简单icon通过引入iconfont进行替换，大图和加载频率低的图片通过上传至JFS平台进行网络加载的方式既有效低减少了包大小，同时也最大程度保证了用户的体验。

下面就是在领京豆业务支撑的过程中的一些沉淀：
这些业务沉淀和技术沉淀有效支撑了领京豆的业务迭代和大促活动页的开发，其中领京豆的2.0版本RN+H5单人22工作日就完美上线，线上已全量，0投诉。

## 关注组件的开发与优化

由于首页大改版，多数频道失去了首页的坑位，频道为了提高用户的留存率往往会开发自己频道的关注组件，但是站内频道众多，使得各个频道开发关注组件造成了一些问题：

> - 重复开发
>
>   频道的关注功能这种通用需求每个频道每种平台都实现一遍造成了研发资源的浪费；
>
> - 依赖发版
>
>   关注组件的日常迭代依赖于发版周期，使得需求的响应速度大打折扣；
>
> - 维护成本高
>
>   一个完整的关注组件需要前后台的研发长期支持和维护，部分频道除了原生还有H5版本，维护成本太高；
>
> - 运营成本高
>
>   运营如果想要通过给关注用户一些激励需要前后端研发资源排期支持，从时效性上来讲难以及时发挥激励的作用，造成虚拟资源的浪费，使得运营成本过高；

那我开发的关注组件是如何解决这些问题呢？总结下来主要包含四个方面：

> - 全平台支持
>
>   关注组件对原生和H5以及RN提供了一致的频道关注能力，简化了接入方式；
>
> - 通用的弹窗策略
>
>   关注组件在引导用户关注频道、领取京豆或者优惠券奖励等场景下提供了弹窗能力，制定出一套完整的弹窗策略。在Android屏幕碎片化的背景下通过全屏弹窗的比例策略和弹窗边距检测策略最大程度保证了用户体验；
>
> - 兼容性高
>
>   关注组件针对不同的平台和折叠屏做了兼容处理，在组件内部抹平了平台差异，使得各个接入方只需要将精力放在自己的业务中，无需关心关注组件的内部逻辑；
>
> - 文档完善
>
>   通过输出了关注组件的接入文档，使得运营和研发人员能够快速熟悉关注组件配置流程和接入细节。运营人员只需要申请一个频道id，研发通过引入组件在自己的布局中并配置频道id，就可以体验到完整的关注组件提供的能力。

下图就是关注组件的架构图：
平台适配层：负责各个平台（Android、RN、H5）的适配和兼容，向上提供了统一的与平台无关的方法支持；
业务逻辑层：负责用户关注频道获得奖励相关的校验、关注状态控制、弹窗弹出策略的控制逻辑
视图层：主要是封装了相关的弹窗和toast，当用户命中了弹窗策略后就会弹出相应的弹窗；
网络层：负责了通过网络接口获取用户关注频道的数据的初始化和用户关注操作的网络请求；
对外接口层：提供了各个平台引入关注组件的入口方法，Android可以直接引入到xml布局文件或者代码直接初始化，RN通过jsbridge桥接文件直接引入，H5通过配置相关参数在导航栏中显示。

通过上述的关注组件的功能封装，实现了一个多平台支持、高可用、高性能、易接入的全站通用的关注组件，目前关注组件接入业务300+，线上0投诉。

## 一种跨平台的动态化的弹窗方案

​	在使用Android和RN开发弹窗支持各种业务的过程中，我们发现弹窗开发作为一种通用的显示任务信息或者提示信息的关键视图要素在频道的开发过程中必不可少，但是弹窗的UI样式、弹出方式有很大的相似性。通过总结目前弹窗开发的现状，我们发现弹窗开发目前面临的四个问题：

> - 重复开发
>
>   缺乏全站统一的弹窗组件，弹窗需要各个业务独立开发，造成了弹窗的重复开发；
>
> - 技术栈不统一
>
>   部分频道原生开发一遍，H5开发一遍，极大的浪费研发资源；
>
> - 配置不灵活
>
>   弹窗的弹出策略需要后端下发字段控制，当运营需要改变弹窗的弹出策略的时候需要后端重新开发支持；
>
> - 依赖发版
>
>   客户端弹窗的开发后需要采用跟版方式上线，不能及时响应紧急需求；

​	面对这些问题，我们团队提出了一种跨平台的动态化弹窗方案，如下图的流程图所示，左边是传统的烟囱式的弹窗研发模式，右边是跨平台的动态化的弹窗研发模式。通过最右边的架构图可以看出，这种动态化弹窗方案主要涉及的代码层次，如红色虚线标识的方框所示。

> - 首先最底层的是弹窗CMS配置平台，该平台主要负责一些采用RN、H5、Flutter、H5等技术栈研发弹窗的bundle文件的上传控制、下载控制、弹窗版本控制以及弹窗策略配置等功能。其中弹窗策略指的将弹窗的一些属性的代码描述或者是DSL描述，比如弹窗的弹窗条件、弹出次数、是否自动弹出、弹窗方式、展示时长等属性。
> - 在组件层中弹窗组件主要负责将CMS平台下发的弹窗bundle文件进行动态的加载、弹窗样式解析、弹窗控制逻辑解析、埋点上报控制、弹窗兜底逻辑控制和弹窗相关的监控功能模块组成。其中弹窗控制逻辑解析就是将上述的CMS平台下发的弹窗策略进行解析的过程。通过这些弹窗策略客户端就能够根据弹窗的命中策略进行实时匹配，命中后将弹窗弹出，弹窗的样式和内部逻辑封装在弹窗的bundle文件中。弹窗bundle文件可以不受app的发版周期的限制，可以采用动态下发的方式进行更新迭代。比如说采用RN开发的弹窗jsBundle文件通过动态下发，客户端通过对比jsbundle的版本后决定是否更新弹窗jsbundle文件。弹窗的弹出条件可以通过cms平台进行动态配置，比如说如果用户打开了商详页，如果此shopid命中了弹窗条件，则自动弹出此弹窗。

左边的第二个流程图说明了这种方案的开发和配置过程。目前此方案已经输出了VK、RN、H5的动态加载的弹窗的方案，并输出了一篇专利（已过综合评审）。

## RN性能监控工具

​	RN性能问题一直是困扰着RN的研发人员，所以RN的研发都或多或少针对RN的性能问题做了优化，但是如何找到这些性能问题的真正原因以及如何量化这些性能优化的实际效果呢。针对这些问题我们急需一个的RN的性能监控工具。这个工具它需要具备以下三个能力：

> - 准确打点
>
>   如何打点以及在哪里打点着基本上决定了性能指标是否合理的关键；
>
> - 实时上报
>
>   实时上报可以让研发人员实时查看自己代码运行时的性能问题，实时排查、实时验证；
>
> - 自动采集
>
>   作为一款性能监控工具必须要减少业务的接入成本；

​	为了解决这些问题，我通过研读RN Android端FrameWork的源码，最终找到了实现了RN性能监控工具的关键方法。具体过程如右图。RN性能监控信息来源主要是jsBridge，RN FrameWork，RN容器。首先看一下jsBridge上报信息过程，RN页面的加载过程需要经过 RN模块的加载、jsbundle解析、网络请求、页面渲染的过程，这其中我们想要获取一些与性能相关的信息的话，需要通过Hook平台相关的方法，比较幸运的是通过研读RN Framework的源码我发现大部分的性能信息都可以在Framework的层面获取，而在业务代码中需要获取的除了网络接口的开始请求时间点和网络请求结束时间点外还需要提供一些业务自定义的上报信息。其中接口请求相关的打点数据可以通过hook接口请求方法的方式获取，业务自定的上报信息和网络接口hook的数据最终通过jsbridge传递给原生的性能监控工具类。

​	在RN的FrameWork代码中存在着一种可以反映了RN运行过程的通知信息。通过对这些通知信息进行分析，发现通知信息的种类多达几十种，最终通过深入源码从这些通知信息中筛选出能够反映RN性能指标的几种通知。接下来就是如何及时获取到这些通知信息，好在RN提供了相关的监听回调，使得我们不需要通过反射即可轻松获取到这些信息，FrameWork 层面的性能数据的实现了无痕采集，代码无侵入。这些数据最终通过jsbridge传递给原生的性能监控工具类。

​	还有一些反映RN模块的描述信息可以通过加载RN Moudle的容器中获取，RN在Android端容器是一个activity，我通过获取跳转到RN所在的activity的intent对象后，我们从中解析到了当前所加载RN模块的名称，版本号等基本描述信息，这些数据最终通过jsbridge传递给原生的性能监控工具类。

​	通过jsBridge、RN Framework、RN容器获取的信息均传递给原生的上传控制模块中，这个模块中包含了开关控制、上报策略的、数据获取、数据过滤和信息上报的能力。开关和上报策略通过后台下发控制。

通过上述的过程最终实现了RN性能监控的完整的能力，其特色为 

> - 自动上报的无侵入
>
>   通过对RN Framework层和RN容器中的通知信息的获取，使得RN业务无需引入任何代码就能获取其性能数据；
>
> - 手动上报易接入
>
>   网络接口耗时性能指标需要业务手动引入性能上报的jsBridge组件即可，在jsBridge中已经实现了对网络接口请求的hook和上报功能，其中jsBridge还提供了业务自定义的信息上报的能力;
>
> - 数据串联易定位
>
>   由于性能上报数据反映的是从RN 的jsBundle开始加载到最终的页面渲染完成的整个过程的串联数据，根据这些串联数据可以轻松排查出RN性能问题的真正原因;

目前此工具作为客户端性能监控项目的一部分，已经实现了平台化。服务业务10+，线上0投诉。