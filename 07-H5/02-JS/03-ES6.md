# let和const

# 箭头函数

## 箭头函数的注意事项

### 箭头函数的简化

- 单个参数

  ```
  const add = (x) =>{
  	return x + 1;
  }
  
  const add = x =>{
  	return x + 1;
  }
  ```

- 单行函数体

  单行函数体可以同时省略 {} 和 return

  ```
  const add = (x,y) => x+y ;
  ```

- 单行对象

  如果箭头函数返回单行对象，可以在{}外面加上()，让浏览器不再认为那是函数体的花括号

  ```
  const add = (x,y) => {
  	return {
  		value:x+y
  	};
  };
  
  const add = (x,y) => ({
  	value:x+y
  });
  ```

## 不适用箭头函数的场景

- 作为构造函数
- 需要this指向调用对象的时候
- 需要使用arguments的时候，箭头函数中没有arguments存在的

# this指向

- 全局作用域中的this指向

  this指向的是window对象

- 一般函数（非箭头函数中）的this指向

  1. 只有在函数调用的时候this指向才确定，不调用的时候，不知道指向谁；
  2. this指向和函数在哪儿调用没有关系，只和谁调用有关；
  3. 构造函数中的this指向的是实例化对象本身；

- 箭头函数中的this指向

  箭头函数没有自己的this

# 解构赋值

## 数组的解构赋值

```javascript
const [ a, b, c ] = [ 1, 2, 3 ];
const [a,[,,b],c] = [1,[2,4,5],3];
```

### 数组解构赋值的原理

- 模式（结构）匹配
- 索引值相同的完成赋值

### 数组解构赋值的默认值

- 默认值的基本用法

  ```
  const [a,b] = []; // [undefined,undefined]
  const [a=1,b=2] = [];
  ```

- 默认值的生效条件

  只有当一个数组成员严格等于（===）undefined时，对应的默认值才会生效

- 默认值表达式

  如果默认值是表达式，默认值表达式是惰性求值的

  ```javascript
  const func = ()=> {
  	console.log('执行');
  	return 2;
  }；
  const [x=func()]=[1]; //如果用不到表达式，表达式不会执行
  const [x=func()]=[]; //此处会执行表达式默认值
  ```

### 数组结构赋值的应用

#### 常见的类数组的解构赋值

- arguments

  ```javascript
  const [a,b] = arguments;
  ```

- NodeList

  ```javascript
  const [p1,p2] = document.querySelectorAll('p');
  ```

#### 函数参数的解构赋值

```javascript
const add = ([x=0,y=0]) => x+y ;
const array = [1,2];
console.log(add(array));
```

#### 交换变量的值

```
let x = 1;
let y = 2;
[x,y] = [y,x];
```



## 对象的解构赋值

- 模式（结构）匹配

  ```javascript
  {} = {}
  ```

- 属性名相同的完成赋值

  ```javascript
  const {age,username} = {username:'Alex',age:18}
  ```

### 对象结构赋值的注意事项

#### 对象的解构赋值的默认值

对象的属性值严格等于undefined时，对应的默认值才会生效

```
const {username='zs',age=0} = {username:'alex'};
```

#### 默认值表达式

如果默认值是表达式，默认值表达式是惰性求值的

#### 将一个已经声明的变量用于解构赋值

如果将一个已经声明的变量用于对象的解构赋值，整个赋值需在圆括号中进行

```javascript
let x = 2;//只有变量存在这种问题
const{x} = {x:1};//此处会报错
({x} = {x:1});//解决办法

[x] = [1];//数组不会有此问题
```

#### 可以取到继承的属性

```javascript
const{toString} = {};
```

### 对象结构赋值的应用

#### 函数参数的结构赋值

```javascript
const logPersonInfo = ({username,age=0}) => console.log(username,age)
logPersonInfo({username:'alex',age:18});
```

#### 复杂的嵌套

```javascript
const obj ={
	x:1,
	y:[2,3,4],
	z:{
		a:5,
		b:6
	}
};

const{x,y:[,yy],z:{b}} = obj;
console.log(yy); // 3
console.log(y); // undefined

const{
  y,
  y:[,yy].
  z,
  z:{
  	b
	}
} = obj;
console.log(y); // [2,3,4]
```

## 其它数据类型的解构赋值

### 字符串的解构赋值

```javascript
// 1. 数组形式的解构赋值
const [a,b,,,c] = 'hello'; // h,e,o

// 2. 对象形式解构赋值
const {0:a, 1:b, lenght} = 'hello';
console.log(a,b,length);
```

### 数值和布尔值的解构赋值

先将等号右边的值转换为对象

```javascript
const{a=1, toString} = 123;
const{b=2, toString} = true;
```

#### Undefined和null的解构赋值

由于undefined和null无法转换为对象，所以对它们进行解构赋值都会报错。

# 对象字面量的增强与函数参数的默认值

## 属性和方法的简洁表示法

- 实例化构造函数生成对象

  ```javascript
  const person = new Object();
  person.age=18;
  ```

- 对象字面量

  ```javascript
  const person={
  	age:18
  }
  ```

- 属性的简洁表示法

  键名和变量或常量名一样的时候，可以只写一个

  ```javascript
  const age = 18;
  const person = {
  	age
  };
  ```

- 方法的简洁表示法

  ```javascript
  const person = {
  	//speak:function(){}
  	speak(){}
  }
  ```

## 方括号语法增强

- 方括号语法的用法

  ```javascript
  const prop = 'age';
  const persion = {};
  
  //person.prop = '18';
  person[prop] = 18;
  
  //方括号语法可以写在对象字面量中
  const person = {
    [prop]:18
  };
  ```

- 方括号中可以放什么

  ```javascript
  const prop ='age;
  const func = ()=>'age';
  const person ={
  	[prop]:18,
  	[func()]:18,
    ['sex']:'male',
    ['s'+'ex']:'male'
  }'
  ```

- 方括号语法和点语法的区别

  1. 点语法是方括号语法的特殊形式，属性名由数字、字母、下划线以及$构成，并且数字还不能打头的时候可以使用点语法；

  2. 当你的属性或方法名是合法标识符时，可以使用点语法，其他情况请使用方括号语法；

# 函数参数的默认值

```javascript
const multiply = (x,y=1) => x*y;
```

## 默认值的生效条件

- 不传参数，或者明确的传递undefined作为参数，只有这两种情况下，默认值才会生效

## 默认值表达式

- 如果默认值是表达式，默认值表达式是惰性求值的

## 小技巧

- 函数参数的默认值，最好从参数列表的右边开始设置

  ```javascript
  const multiply = (x=1,y)=>x*y;
  multiply(undefined,2);
  ```

## 函数参数默认值的应用

```javascript
const logUser = ({username='zs',age=18}={}) => console.log(username);
logUser();
```





