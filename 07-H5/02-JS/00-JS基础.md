# 函数

## 函数优先提升

<img src="img/image-20221205213958881.png" alt="image-20221205213958881" style="zoom:50%;" />

## arguments

- 函数内arguments表示它接收到的实参列表，它是一个类数组对象
- 类数组对象：所有属性均为从0开始的自然序列，并且有length属性，和数组类似可以用方括号写下标访问对象的某个属性值，但是不能调用数组的方法

<img src="img/image-20221205214941612.png" alt="image-20221205214941612" style="zoom: 80%;" />

## 遮蔽效应

- 如果函数中也定义了和全局同名的变量，则函数内的变量会将全局的变量遮蔽

  <img src="img/image-20221205220630996.png" alt="image-20221205220630996" style="zoom: 67%;" />

## 变量声明提升

<img src="img/image-20221205221054737.png" alt="image-20221205221054737" style="zoom: 67%;" />

## 形参是局部变量

<img src="img/image-20221205221248167.png" alt="image-20221205221248167" style="zoom:67%;" />

## 作用域链

- 在函数嵌套中，变量会从内岛外逐层寻找它的定义。

## 不加var将定义全局变量

- 在初次给变量赋值时，如果没有加var，则将定义全局变量

# 闭包

- 闭包是函数本身和该函数声明时所处的环境状态的组合
- 函数能够‘记忆住’其定义时所处的环境，即函数不在其定义的环境中被调用，也能访问定义时所处环境的变量
- 闭包很有用，因为它允许我们将数据与操作该数据的函数关联起来
- 闭包的功能：记忆性、模拟私有变量

### 记忆性

- 当闭包产生时，函数所处环境的状态会始终保持在内存中，不会在外层函数调用后被自动清除

<img src="img/image-20221205222919648.png" alt="image-20221205222919648" style="zoom:67%;" />

### 模拟私有变量

<img src="img/image-20221205223236655.png" alt="image-20221205223236655" style="zoom:67%;" />

### 使用闭包的注意点

- 不能滥用闭包，否则会造成网页的性能问题，严重时可能导致内存泄漏。

## IIFE

- IIFE（Immediately Invoked Function Expression），立即调用函数表达式，是一种特殊的JavaScript函数写法，一旦被定义就立即被调用

<img src="img/image-20221205223841106.png" alt="image-20221205223841106" style="zoom:67%;" />

- 函数不能直接加圆括号被调用

- 函数必须转为“函数表达式”才能被调用

  <img src="img/image-20221205224019821.png" alt="image-20221205224019821" style="zoom:80%;" />

### IIFE的作用

- 为变量赋值：当给变量赋值需要一些较为复杂的计算时（如if语句），使用IIFE显得语法更紧凑

  <img src="img/image-20221205224234038.png" alt="image-20221205224234038" style="zoom:67%;" />

- IIFE可以再一些场合（如for循环中）将全局变量变为局部变量，语法显得紧凑

<img src="img/image-20221205224542370.png" alt="image-20221205224542370" style="zoom:67%;" />

<img src="img/image-20221205225236395.png" alt="image-20221205225236395" style="zoom:67%;" />

# DOM

- DOM是JS操作HTML和CSS的桥梁

## 改变元素节点中的内容

- 改变元素节点中的内容可以使用两个相关属性： 1. innerHTML	2. innerText
- innerHTML属性能以HTML语法设置节点中的内容
- innerText属性只能以纯文本的形式设置节点中的内容

## 节点的创建

- document.createElement()方法用于创建一个制定tagname的HTML元素

- 必须继续使用appendChild()或insertBefore()方法将孤儿节点插入到DOM树上

- 任何已经在DOM树上的节点，都可以调用appendChild()方法，他可以将孤儿节点挂载到它的内部，成为他的最后一个子节点

  ```
  父节点.appendChild(孤儿节点)
  ```

  

- 任何已经在DOM树上的节点，都可以调用insertBefore()方法，他可以将孤儿节点挂载到它的内部，成为他的”标杆子节点“之前的节点

  ```
  父节点.insertBefore(孤儿节点，标杆节点)
  ```

## 移动节点

- 如果将已经挂载到DOM树上的节点成为appendChild()或者insertBefore()的参数，这个节点将会被移动

  ```
  新父节点.appendChild(已经有父亲的节点)
  新父节点.insertBefore(已经有父亲的节点,标杆子节点)
  ```

- 这意味着一个节点不能同时位于DOM树的两个位置

## 删除节点

- removeChild()方法从DOM中删除一个子节点

  ```
  父节点.removeChild(要删除子节点)
  ```

- 节点不能主动删除自己，必须由父节点删除它

## 克隆节点

- cloneNode()方法可以克隆节点，克隆出的节点是“孤儿节点”

  ```
  var 孤儿节点 = 老节点.cloneNode();
  var 孤儿节点 = 老节点.cloneNode(true);
  ```

- 参数是一个布尔值，表示的是否采用深度克隆：如果为true，则该节点的所有后代节点也都会被克隆，如果为false，则只克隆该节点本身

## 改变节点的CSS样式

- 改变元素节点的CSS样式需要使用这样的语句：

  <img src="img/image-20221207223217018.png" alt="image-20221207223217018" style="zoom:50%;" />

## 改变节点的HTML属性

- 标准W3C属性，如src、href等等，只需要直接打点进行更改即可

  ```
  oImg.src = 'images/2.jpg';
  ```

- 不符合W3C标准的属性，要使用setAttribute()和getAttribute()来设置、读取

  ```
  oBox.setAttribute('data-n',10);
  var n = oBox.getAttribute('data-n');
  alert(n);
  ```

## nodeType常用属性值

- 节点的nodeType属性可以显示这个节点具体的类型

  <img src="img/image-20221207225203489.png" alt="image-20221207225203489" style="zoom:50%;" />

## 访问元素节点

### document

- document对象是DOM中最重要的东西，几乎所有DOM的功能都封装在了document对象中
- document对象表示整个HTML文档，它是DOM节点树的根
- document对象的nodeType属性值是9

### 访问元素节点的常用方法

<img src="img/image-20221207225913558.png" alt="image-20221207225913558" style="zoom:50%;" />

- 如果页面上有相同id的元素，则只能获取第一个
- var ps = oBox.getElementsByTagName('p')
- var the_p = document.querySelector( '#box1 .spec');

## 延迟运行

- 通常JS代码一定要写到HTML节点的后面，否则JS无法找到相应HTML节点
- 可以使用 window.onload = function(){} 事件，使页面加载完毕后，再执行指定的代码

## 节点的关系

- DOM中，文本节点也属于节点，在使用节点的关系时一定要注意
- 在标准的W3C规范中，空白文本节点也应该算作节点，但是在IE8及以前的浏览器中会有一定的兼容问题，他们不把空文本节点当做节点

<img src="img/image-20221212214738444.png" alt="image-20221212214738444" style="zoom:50%;" />

### 排除文本节点的干扰

- 从IE9开始支持一些“只考虑元素节点”的属性

  <img src="img/image-20221212215140535.png" alt="image-20221212215140535" style="zoom:50%;" />

# Event

## 事件对象

### 鼠标位置

```
oBox.onmousemove = function(e){
	
}
```

<img src="img/image-20221212221416506.png" alt="image-20221212221416506" style="zoom:60%;" />

## 事件监听

### 常见的鼠标事件监听

<img src="img/image-20221212230705866.png" alt="image-20221212230705866" style="zoom:50%;" />

### 常见的键盘事件监听

<img src="img/image-20221212231646204.png" alt="image-20221212231646204" style="zoom:50%;" />

### 常见的表单事件监听

<img src="img/image-20221212233804380.png" alt="image-20221212233804380" style="zoom:50%;" />

### 常见的页面事件监听

<img src="img/image-20221212233846925.png" alt="image-20221212233846925" style="zoom:50%;" />

## 事件传播

- 事件的传播是从外到内，然后再从内到外

  <img src="img/image-20221212224250406.png" alt="image-20221212224250406" style="zoom:50%;" />

- onxxx这样的写法只能监听冒泡阶段，DOM0级事件监听

  ```
  oBox.onclick = function(){
  	
  }
  ```

- addEventListener()，DOM2级事件监听

  ```
  oBox.addEventListener('click', function(){
  	//这是事件处理函数
  },true)；
  ```

<img src="img/image-20221212224933232.png" alt="image-20221212224933232" style="zoom:50%;" />

### 注意事项

- 最内部元素不再区分捕获和冒泡节点，会先执行写在前面的监听，然后执行后写的监听
- 如果给元素设置相同的两个或多个同名事件，则DOM0级写法后面写的会覆盖先写的；而DOM2级会按顺序执行

## e.charCode & e.keyCode

- e.cahrCode属性通常用于onkeypress事件中，表示用户输入的字符的“字符码”
- e.keyCode属性通常用于onkeydown事件和onkeyup中，表示用户按下的按键的“键码”

### charCode

<img src="img/image-20221213220106660.png" alt="image-20221213220106660" style="zoom:50%;" />

### keyCode

<img src="img/image-20221213220136467.png" alt="image-20221213220136467" style="zoom:50%;" />

## e.preventDefault

- e.preventDefault()方法用来阻止事件产生的“默认动作”

## e.stopPropagation()

- e.stoppropagation()方法用来阻止事件继续传播

## 事件委托

- 利用事件的冒泡机制，将后代元素事件委托给祖先元素

  <img src="img/image-20221213223946052.png" alt="image-20221213223946052" style="zoom:50%;" />

### e.target & e.currentTarget

- 事件委托通常需要结合使用e.target属性

  <img src="img/image-20221213224106956.png" alt="image-20221213224106956" style="zoom:50%;" />

<img src="img/image-20221213224514044.png" alt="image-20221213224514044" style="zoom:60%;" />

- 当有大量蕾丝元素需要批量添加事件监听时，使用事件委托可以减少内存开销
- 当有动态元素节点上树时，使用事件委托可以让新上树的元素具有事件监听

### 注意事项

- onmouseenter和onmouseover都表示“鼠标进入”，它们有什么区别呢？

  答：onmouseenter不冒泡，onmouseover冒泡

- 使用事件委托时要注意：不能委托不冒泡的事件给祖先元素
- 使用事件委托时要注意：最内层的元素不能再有额外的内层元素了

# 定时器

- setInterval()函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔

  ```
  setInterval(function(){
  	//这个函数将自动被以固定间隔事件调用
  },2000)
  ```

## 函数的参数

- setInterval()函数可以接收第3、4...个参数，它们将按顺序传入函数

  <img src="img/image-20221213230657331.png" alt="image-20221213230657331" style="zoom:50%;" />

- 具名函数也可以传入setInterval()

  <img src="img/image-20221213230814445.png" alt="image-20221213230814445" style="zoom:50%;" />

## 清除定时器

- clearInterval()函数可以清除一个定时器

  <img src="img/image-20221213231021789.png" alt="image-20221213231021789" style="zoom:50%;" />

# 延时器

- setTimeout()函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不再重复执行

  ```
  setTimeout(function(){
  	//这个函数会在2秒后执行一次
  },2000)
  ```

## 清除延时器

- clearTimeout()函数可以清除延时器，和clearInterval()非常类似
- setInterval() 和 setTimeout()是两个异步语句

## 使用定时器实现动画

# JS和CSS3结合实现动画

```jsx
btn.onclick = function(){
	//加上过度
	box.style.transition = 'all 2s linear 0s';
	//瞬间移动，但是由于有过度，所以是动画
	box.style.left = '1100px';
}
```

## 函数节流

<img src="img/image-20221214220841578.png" alt="image-20221214220841578" style="zoom:50%;" />

## 无缝滚动动画

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 1000px;
            height: 130px;
            border: 1px solid #000;
            margin: 50px auto;
            overflow: hidden;
        }

        .box ul {
            list-style: none;
            /* 设置大一点，这样li才能浮动 */
            width: 5000px;
            position: relative;
        }

        .box ul li {
            float: left;
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div id="box" class="box">
        <ul id="list">
            <li><img src="images/number/0.png" alt=""></li>
            <li><img src="images/number/1.png" alt=""></li>
            <li><img src="images/number/2.png" alt=""></li>
            <li><img src="images/number/3.png" alt=""></li>
            <li><img src="images/number/4.png" alt=""></li>
            <li><img src="images/number/5.png" alt=""></li>
        </ul>
    </div>
    <script>
        var box = document.getElementById('box');
        var list = document.getElementById('list');

        // 复制多一遍所有的li
        list.innerHTML += list.innerHTML;

        // 全局变量，表示当前list的left值
        var left = 0;

        // 定时器，全局变量
        var timer;

        move();

        // 动画封装成函数
        function move() {
            // 设表先关，防止动画积累
            clearInterval(timer);

            timer = setInterval(function () {
                left -= 4;
                // 验收
                if (left <= - 1260) {
                    left = 0;
                }
                list.style.left = left + 'px';
            }, 20);
        }

        // 鼠标进入停止定时器
        box.onmouseenter = function () {
            clearInterval(timer);
        };

        // 鼠标离开继续定时器
        box.onmouseleave = function () {
            move();
        };
    </script>
</body>

</html>
```

## 跑马灯动画

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .carousel {
            width: 650px;
            height: 360px;
            border: 1px solid #000;
            margin: 50px auto;
            position: relative;
            overflow: hidden;
        }
        .carousel ul {
            list-style: none;
            width: 6000px;
            position: relative;
            left: 0px;
            transition: left .5s ease 0s;
        }
        .carousel ul li {
            float: left;
        }
        .carousel .leftbtn {
            position: absolute;
            left: 20px;
            top: 50%;
            margin-top: -25px;
            width: 50px;
            height: 50px;
            background-color: rgb(28, 180, 226);
            border-radius: 50%;
        }
        .carousel .rightbtn {
            position: absolute;//子绝对布局，父相对布局（子绝父相）
            right: 20px;
            top: 50%;
            margin-top: -25px;
            width: 50px;
            height: 50px;
            background-color: rgb(28, 180, 226);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="carousel">
        <ul id="list">
            <li><img src="images/beijing/0.jpg" alt=""></li>
            <li><img src="images/beijing/1.jpg" alt=""></li>
            <li><img src="images/beijing/2.jpg" alt=""></li>
            <li><img src="images/beijing/3.jpg" alt=""></li>
            <li><img src="images/beijing/4.jpg" alt=""></li>
        </ul>
        <a href="javascript:;" class="leftbtn" id="leftbtn"></a>
        <a href="javascript:;" class="rightbtn" id="rightbtn"></a>
    </div>
    <script>
        // 得到按钮和ul，ul整体进行运动
        var leftbtn = document.getElementById('leftbtn');
        var rightbtn = document.getElementById('rightbtn');
        var list = document.getElementById('list');

        // 克隆第一张图片
        var cloneli = list.firstElementChild.cloneNode(true);
        list.appendChild(cloneli);

        // 当前ul显示到第几张了，从0开始数
        var idx = 0;

        // 节流锁
        var lock = true;

        // 右边按钮监听
        rightbtn.onclick = function () {
            // 判断锁的状态
            if (!lock) return; 

            lock = false;

            // 给list加过渡，为什么要加？？css中不是已经加了么？？这是因为最后一张图片会把过渡去掉
            list.style.transition = 'left .5s ease 0s';
            idx ++;
            if (idx > 4) {
                // 设置一个延时器，延时器的功能就是将ul瞬间拉回0的位置，延时器的目的就是让过渡动画结束之后
                setTimeout(function() {
                    // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”回去
                    list.style.transition = 'none';
                    list.style.left = 0;
                    idx = 0;
                }, 500);
            }
            list.style.left = -idx * 650 + 'px';

            // 函数节流
            setTimeout(function() {
                lock = true; 
            }, 500);
        }

        // 左边按钮监听
        leftbtn.onclick = function () {
            if (!lock) return;

            lock = false;

            // 判断是不是第0张，如果是，就要瞬间用假的替换真的
            if (idx == 0) {
                // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”过去
                list.style.transition = 'none';
                // 直接瞬间移动到最后的假图片上
                list.style.left = -5 * 650 + 'px';
                // 设置一个延时器，这个延时器的延时时间可以是0毫秒，虽然是0毫秒，但是可以让我们过渡先是瞬间取消，然后再加上
                setTimeout(function() {
                    // 加过渡
                    list.style.transition = 'left .5s ease 0s';
                    // idx改为真正的最后一张
                    idx = 4;
                    list.style.left = -idx * 650 + 'px';
                }, 0);
            } else {
                idx --;
                list.style.left = -idx * 650 + 'px';
            }
            
            // 函数节流
            setTimeout(function() {
                lock = true; 
            }, 500);
        }
    </script>
</body>
</html>
```

## 呼吸轮播图

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .carousel {
            width: 650px;
            height: 360px;
            border: 1px solid #000;
            margin: 50px auto;
            position: relative;

        }

        .carousel ul {
            list-style: none;
        }

        .carousel ul li {
            position: absolute;
            top: 0;
            left: 0;
            /* 透明度都是0 */
            opacity: 0;
            transition: opacity 1s ease 0s;
        }

        /* 只有第一张透明度是1 */
        .carousel ul li:first-child {
            opacity: 1;
        }

        .carousel .leftbtn {
            position: absolute;
            left: 20px;
            top: 50%;
            margin-top: -25px;
            width: 50px;
            height: 50px;
            background-color: rgb(28, 180, 226);
            border-radius: 50%;
        }

        .carousel .rightbtn {
            position: absolute;
            right: 20px;
            top: 50%;
            margin-top: -25px;
            width: 50px;
            height: 50px;
            background-color: rgb(28, 180, 226);
            border-radius: 50%;
        }
    </style>
</head>

<body>
    <div class="carousel">
        <ul id="list">
            <li><img src="images/beijing/0.jpg" alt=""></li>
            <li><img src="images/beijing/1.jpg" alt=""></li>
            <li><img src="images/beijing/2.jpg" alt=""></li>
            <li><img src="images/beijing/3.jpg" alt=""></li>
            <li><img src="images/beijing/4.jpg" alt=""></li>
        </ul>
        <a href="javascript:;" class="leftbtn" id="leftbtn"></a>
        <a href="javascript:;" class="rightbtn" id="rightbtn"></a>
    </div>
    <script>
        // 得到按钮和ul，ul整体进行运动
        var leftbtn = document.getElementById('leftbtn');
        var rightbtn = document.getElementById('rightbtn');
        var list = document.getElementById('list');
        var lis = list.getElementsByTagName('li');

        // 当前是第几张图显示
        var idx = 0;

        // 节流
        var lock = true;

        // 右按钮
        rightbtn.onclick = function () {
            // 判断节流
            if (!lock) return;

            lock = false;

            // 还没有改idx，此时的idx这个图片就是老图，老图淡出
            lis[idx].style.opacity = 0;
            idx++;
            if (idx > 4) idx = 0;
            // 改了idx，此时的idx这个图片就是新图，新图淡入
            lis[idx].style.opacity = 1;

            // 动画结束之后，开锁
            setTimeout(function () {
                lock = true;
            }, 1000);
        }

        // 左按钮
        leftbtn.onclick = function () {
            // 判断节流
            if (!lock) return;

            lock = false;

            // 还没有改idx，此时的idx这个图片就是老图，老图淡出
            lis[idx].style.opacity = 0;
            idx--;
            if (idx < 0) idx = 4;
            // 改了idx，此时的idx这个图片就是新图，新图淡入
            lis[idx].style.opacity = 1;

            // 动画结束之后，开锁
            setTimeout(function () {
                lock = true;
            }, 1000);
        }
    </script>
</body>

</html>
```

# BOM

## Window

- window对象是当前JS脚本运行所处的窗口，而这个窗口中包含DOM结构，window.document属性就是document对象

- 在有标签页功能的浏览器中，每个标签都拥有自己的window对象；同一个窗口的标签页之间不会共享一个window对象

- 全局变量会成为window对象的属性，多个js文件之间是共享全局作用域的，即js文件没有作用域隔离功能

  ```
  var a = 10 ;
  console.log( window.a == a); //true
  ```

- 如setInterval() 、alert()等内置函数，普遍都是window的方法

### 窗口尺寸相关属性

- 获得不包含滚动条的窗口宽度，要用 document.documentElement.clientWidth

<img src="img/image-20221215215847118.png" alt="image-20221215215847118" style="zoom:50%;" />

### resize事件

- 在窗口大小改变之后，就会触发resize事件，可以使用window.onresize或者window.addEventListener(’resize‘)来绑定事件处理函数

### 已滚动高度

- window.scrollY属性表示在垂直方向已滚动的像素值
- document.documentElement.scrollTop属性也表示窗口滚动的高度
- document.documentElement.scrollTop不是只读的，而window.scrollY是只读的

```
var scrollTop = window.scrollY || document.document.documentElement.scrollTop;
```

- 返回页面顶部可使用document.documentElement.scrollTop = 0

### scroll事件

- 在窗口被卷动之后，就会触发scroll事件，可以使用window.onscroll或者window.addEventListener('scroll')来绑定事件处理函数

## Navigator

- window.navigator属性可以检索navigator对象，它内部含有用户此次活动的**浏览器**的相关属性和标识

  <img src="img/image-20221215222332901.png" alt="image-20221215222332901" style="zoom:50%;" />

## History

- window.history对象提供了来操作浏览器会话历史的接口

- 常用操作就是模拟浏览器回退按钮

  ```
  history.back() //等同于点击浏览器的回退按钮
  history.go(-1) //等同于history.back()；
  <a href="javascript:history.back();">回退</a>
  ```

## Location

- window.location标识当前所在的网址，可以通过给这个属性赋值命令浏览器进行页面跳转

  ```
  window.location = 'http://www.xxx.com';
  window.location.href = 'http://xxx.com';
  ```

### 刷新页面

- 可以调用location的reload方法以重新加载当前页面，参数true表示强制从服务器强制加载

  ```
  window.location.reload(true);
  ```

### get请求查询参数

- window.location.search属性即为当前浏览器的GET请求查询参数

## BOM特效

### 一键置顶

- 返回顶部的原理：改变document.documentElement.scrollTop属性，通过定时器逐步改变此值，则将用动画形式返回顶部

### 锚点导航

- DOM元素都有officeTop属性，表示此元素到定位祖先元素的垂直距离
- 定位祖先元素：在祖先中，离自己最近的且拥有定位属性的元素

<img src="img/image-20221215231333175.png" alt="image-20221215231333175" style="zoom:70%;" />

# 对象

## 认识对象

- 对象（object）是“键值对”的集合，表示属性和值的映射关系

- 如果对象的属性键名不符合JS标识符命名规范，则这个键名必须用引号包裹

- <img src="img/image-20221217220803728.png" alt="image-20221217220803728" style="zoom:50%;" />

- 如果属性名不符合JS标识符命名规范，则必须用方括号的写法来访问

  ```
  xiaoming['favorite-book']
  ```

- 如果属性名以变量形式存储，则必须使用方括号形式

  <img src="img/image-20221217221204009.png" alt="image-20221217221204009" style="zoom:50%;" />

- 如果要删除某个对象的属性，需要使用delete操作符

  ```
  var obj = {
  	a : 1,
  	b : 2
  };
  delete obj.a;
  ```

## 对象的方法

- 如果对象的某个属性是函数，则它也被称为对象的“方法”

## 对象的遍历

- 和遍历数组类似，对象也可以遍历，遍历对象需要使用 for...in... 循环

- 使用 for...in... 循环可以遍历对象的每个键

  <img src="img/image-20221218135118242.png" alt="image-20221218135118242" style="zoom:50%;" />

## 对象的深浅克隆

<img src="img/image-20221218135651976.png" alt="image-20221218135651976" style="zoom:50%;" />



## 函数上下文

### 上下文规则

### call & apply

## 构造函数

## 原型和原型链

### prototype和原型链查找

### 在prototype上添加方法

### 原型链的终点

### 继承

## 面向对象

## JS的内置对象





